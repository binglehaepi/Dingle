import { GoogleGenAI } from "@google/genai";
import { ScrapType, ScrapMetadata } from "../types";

// ------------------------------------------------------------------
// âš ï¸ DEPRECATED - ì •ì±… ì¤€ìˆ˜ ìœ„ë°˜
// ------------------------------------------------------------------
// ì´ íŒŒì¼ì€ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
// ëª¨ë“  ìŠ¤í¬ë˜í•‘ì€ /api/scrap ì„œë²„ APIë¥¼ í†µí•´ì„œë§Œ ìˆ˜í–‰ë©ë‹ˆë‹¤.
//
// âŒ ì œê±°ëœ ê¸°ëŠ¥:
// - í´ë¼ì´ì–¸íŠ¸ CORS í”„ë¡ì‹œ (allorigins, corsproxy)
// - ë¹„ê³µì‹ API ì§ì ‘ í˜¸ì¶œ
// - SNS ì›ë¬¸ ì €ì¥
//
// âœ… ëŒ€ì²´:
// - services/apiClient.ts ì‚¬ìš©
// - ì„œë²„ API (/api/scrap)ë¥¼ í†µí•œ ì•ˆì „í•œ ìŠ¤í¬ë˜í•‘
//
// ì´ íŒŒì¼ì€ ë ˆê±°ì‹œ ì§€ì› ë˜ëŠ” ê°œë°œ ì°¸ê³ ìš©ìœ¼ë¡œë§Œ ìœ ì§€ë©ë‹ˆë‹¤.
// ------------------------------------------------------------------

// --- 1. Caching Layer (In-Memory) ---
// Stores metadata to prevent redundant API calls and speed up the UI.
const CACHE_TTL_MS = 1000 * 60 * 60 * 24; // 24 Hours Cache
const memoryCache = new Map<string, { data: ScrapMetadata; timestamp: number }>();

const getCachedData = (url: string): ScrapMetadata | null => {
  const cached = memoryCache.get(url);
  if (!cached) return null;
  
  // Check Expiry
  if (Date.now() - cached.timestamp > CACHE_TTL_MS) {
    memoryCache.delete(url);
    return null;
  }
  return cached.data;
};

const setCachedData = (url: string, data: ScrapMetadata) => {
  // Save to memory (In Prod, use Redis)
  memoryCache.set(url, { data, timestamp: Date.now() });
};

// --- 2. Platform Specific Fetchers ---

// âš ï¸ DEPRECATED - ì„œë²„ API ì‚¬ìš© ê¶Œì¥
const fetchPinterest = async (url: string): Promise<ScrapMetadata | null> => {
  console.warn('âš ï¸ fetchPinterestëŠ” deprecatedì…ë‹ˆë‹¤. /api/scrapì„ ì‚¬ìš©í•˜ì„¸ìš”.');
  
  try {
    const oembedUrl = `https://www.pinterest.com/oembed.json?url=${encodeURIComponent(url)}`;
    
    // âŒ í”„ë¡ì‹œ ì œê±°ë¨ - ì§ì ‘ í˜¸ì¶œ (CORS ì—ëŸ¬ ë°œìƒ ê°€ëŠ¥)
    console.log(`ğŸ”„ í•€í„°ë ˆìŠ¤íŠ¸ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (í”„ë¡ì‹œ ì—†ì´)...`);
    
    // íƒ€ì„ì•„ì›ƒ ì„¤ì • (7ì´ˆ)
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 7000);

        const response = await fetch(proxyUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
          console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì‹¤íŒ¨: ${response.status}`);
          continue;
        }

        const data = await response.json();
        console.log('âœ… í•€í„°ë ˆìŠ¤íŠ¸ OEmbed ë°ì´í„° ì„±ê³µ:', data);

        return {
          title: data.title || "Pinterest Pin",
          subtitle: data.author_name || "Pinterest",
          description: "Pinterestì—ì„œ í•€ì„ ìŠ¤í¬ë©í–ˆìŠµë‹ˆë‹¤.",
          imageUrl: data.thumbnail_url,
          url: url,
          themeColor: "#E60023",
          isEditable: false
        };
      } catch (proxyError) {
        console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì—ëŸ¬:`, proxyError);
        if (i === PROXIES.length - 1) {
          throw proxyError;
        }
      }
    }

    throw new Error("All proxies failed");

  } catch (e) {
    console.error("âŒ Pinterest OEmbed Fetch ì™„ì „ ì‹¤íŒ¨:", e);
    // Fallback ë°ì´í„° ë°˜í™˜
    return {
      title: "Pinterest Pin",
      subtitle: "Pinterest",
      description: "í•€í„°ë ˆìŠ¤íŠ¸ ë§í¬ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
      imageUrl: "",
      url: url,
      themeColor: "#E60023",
      isEditable: true
    };
  }
};

// ğŸ¦ íŠ¸ìœ„í„° íŠ¸ìœ— ID ì¶”ì¶œ í•¨ìˆ˜
const extractTweetId = (url: string): string | null => {
  // ë‹¤ì–‘í•œ íŠ¸ìœ„í„° URL í˜•ì‹ ì§€ì›
  const patterns = [
    /twitter\.com\/\w+\/status\/(\d+)/,
    /x\.com\/\w+\/status\/(\d+)/,
    /twitter\.com\/.*\/statuses\/(\d+)/,
    /x\.com\/.*\/statuses\/(\d+)/,
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
  return null;
};

// ğŸ¦ íŠ¸ìœ„í„°(X) ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (Syndication API ì‚¬ìš©)
const fetchTwitterOEmbed = async (url: string): Promise<ScrapMetadata | null> => {
  try {
    const tweetId = extractTweetId(url);
    
    if (!tweetId) {
      console.warn("âš ï¸ íŠ¸ìœ— IDë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
      throw new Error("Invalid Twitter URL");
    }

    console.log(`ğŸ”„ íŠ¸ìœ— ID: ${tweetId} ë°ì´í„° ê°€ì ¸ì˜¤ê¸°...`);

    // CORS ìš°íšŒ í”„ë¡ì‹œ ëª©ë¡
    const PROXIES = [
      (url: string) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url: string) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
    ];
    
    // Twitter Syndication API (ê³µì‹ ë¹„ê³µê°œ APIì´ì§€ë§Œ ê³µê°œì ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥)
    const syndicationUrl = `https://cdn.syndication.twimg.com/tweet-result?id=${tweetId}&lang=ko`;
    
    // Syndication API ì‹œë„
    for (let i = 0; i < PROXIES.length; i++) {
      try {
        const proxyUrl = PROXIES[i](syndicationUrl);
        console.log(`ğŸ”„ Syndication API ì‹œë„ (í”„ë¡ì‹œ ${i + 1}/${PROXIES.length})...`);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 7000);

        const response = await fetch(proxyUrl, { 
          signal: controller.signal,
          headers: {
            'Accept': 'application/json'
          }
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
          console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì‹¤íŒ¨: ${response.status}`);
          continue;
        }
        
        const data = await response.json();
        console.log('âœ… íŠ¸ìœ„í„° Syndication ë°ì´í„° ì„±ê³µ:', data);

        // ë°ì´í„° ì¶”ì¶œ
        const author = data.user?.name || "Twitter User";
        const username = data.user?.screen_name || "";
        const tweetText = data.text || "";
        const profileImage = data.user?.profile_image_url_https || "";
        
        // ì´ë¯¸ì§€ ì¶”ì¶œ (ì—¬ëŸ¬ ì´ë¯¸ì§€ ì¤‘ ì²« ë²ˆì§¸)
        let imageUrl = "";
        if (data.photos && data.photos.length > 0) {
          imageUrl = data.photos[0].url;
        } else if (data.video?.poster) {
          imageUrl = data.video.poster;
        }

        // í†µê³„ ì •ë³´
        const likes = data.favorite_count || 0;
        const retweets = data.retweet_count || 0;
        const replies = data.reply_count || 0;

        return {
          title: `${author}${username ? ` (@${username})` : ''}`,
          subtitle: "Twitter (X)",
          description: tweetText,
          imageUrl: imageUrl,
          url: url,
          themeColor: "#000000",
          isEditable: false,
          // íŠ¸ìœ„í„° í†µê³„ ì •ë³´ë¥¼ descriptionì— ì¶”ê°€
          twitterStats: {
            likes,
            retweets,
            replies,
            profileImage
          }
        };
      } catch (proxyError) {
        console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì—ëŸ¬:`, proxyError);
        if (i === PROXIES.length - 1) {
          throw proxyError;
        }
      }
    }

    throw new Error("All proxies failed");

  } catch (e) {
    console.error("âŒ Twitter Fetch ì™„ì „ ì‹¤íŒ¨:", e);
    
    // Fallback: OEmbed API ì‹œë„
    try {
      const targetUrl = url.replace("x.com", "twitter.com");
      const oembedUrl = `https://publish.twitter.com/oembed?url=${encodeURIComponent(targetUrl)}`;
      const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(oembedUrl)}`;
      
      const response = await fetch(proxyUrl);
      if (response.ok) {
        const data = await response.json();
        return {
          title: data.author_name ? `${data.author_name}ë‹˜ì˜ íŠ¸ìœ—` : "Twitter Post",
          subtitle: "Twitter (X)",
          description: "íŠ¸ìœ— ë‚´ìš©ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
          imageUrl: "",
          url: url,
          themeColor: "#000000",
          isEditable: false
        };
      }
    } catch {}
    
    // ì™„ì „ ì‹¤íŒ¨ ì‹œ
    return {
      title: "Twitter Post",
      subtitle: "X / Twitter",
      description: "íŠ¸ìœ„í„° ë§í¬ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
      imageUrl: "",
      url: url,
      themeColor: "#000000",
      isEditable: true
    };
  }
};

// ğŸµ ìŠ¤í¬í‹°íŒŒì´ OEmbed (ìŒì•…)
const fetchSpotify = async (url: string): Promise<ScrapMetadata | null> => {
  try {
    const oembedUrl = `https://open.spotify.com/oembed?url=${encodeURIComponent(url)}`;
    
    const PROXIES = [
      (url: string) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url: string) => `https://corsproxy.io/?${encodeURIComponent(url)}`
    ];

    for (let i = 0; i < PROXIES.length; i++) {
      try {
        const proxyUrl = PROXIES[i](oembedUrl);
        console.log(`ğŸ”„ ìŠ¤í¬í‹°íŒŒì´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹œë„ (í”„ë¡ì‹œ ${i + 1}/${PROXIES.length})...`);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 7000);

        const response = await fetch(proxyUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
          console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì‹¤íŒ¨: ${response.status}`);
          continue;
        }

        const data = await response.json();
        console.log('âœ… ìŠ¤í¬í‹°íŒŒì´ OEmbed ë°ì´í„° ì„±ê³µ:', data);

        return {
          title: data.title || "Spotify Music",
          subtitle: "Spotify",
          description: "ì˜¤ëŠ˜ì˜ ì¶”ì²œ ìŒì•… ğŸµ",
          imageUrl: data.thumbnail_url,
          url: url,
          themeColor: "#1DB954",
          isEditable: false
        };
      } catch (proxyError) {
        console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì—ëŸ¬:`, proxyError);
        if (i === PROXIES.length - 1) throw proxyError;
      }
    }

    throw new Error("All proxies failed");

  } catch (e) {
    console.error("âŒ Spotify OEmbed Fetch ì™„ì „ ì‹¤íŒ¨:", e);
    return {
      title: "Spotify Music",
      subtitle: "Spotify",
      description: "ìŠ¤í¬í‹°íŒŒì´ ë§í¬ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
      imageUrl: "",
      url: url,
      themeColor: "#1DB954",
      isEditable: true
    };
  }
};

// ğŸ“± í‹±í†¡ OEmbed (ìˆí¼)
const fetchTikTok = async (url: string): Promise<ScrapMetadata | null> => {
  try {
    const oembedUrl = `https://www.tiktok.com/oembed?url=${encodeURIComponent(url)}`;
    
    const PROXIES = [
      (url: string) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url: string) => `https://corsproxy.io/?${encodeURIComponent(url)}`
    ];

    for (let i = 0; i < PROXIES.length; i++) {
      try {
        const proxyUrl = PROXIES[i](oembedUrl);
        console.log(`ğŸ”„ í‹±í†¡ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹œë„ (í”„ë¡ì‹œ ${i + 1}/${PROXIES.length})...`);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 7000);

        const response = await fetch(proxyUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
          console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì‹¤íŒ¨: ${response.status}`);
          continue;
        }

        const data = await response.json();
        console.log('âœ… í‹±í†¡ OEmbed ë°ì´í„° ì„±ê³µ:', data);

        return {
          title: data.title || "TikTok Video",
          subtitle: data.author_name ? `@${data.author_name}` : "TikTok",
          description: "í‹±í†¡ ì˜ìƒ ìŠ¤í¬ë©",
          imageUrl: data.thumbnail_url,
          url: url,
          themeColor: "#000000",
          isEditable: false
        };
      } catch (proxyError) {
        console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì—ëŸ¬:`, proxyError);
        if (i === PROXIES.length - 1) throw proxyError;
      }
    }

    throw new Error("All proxies failed");

  } catch (e) {
    console.error("âŒ TikTok OEmbed Fetch ì™„ì „ ì‹¤íŒ¨:", e);
    return {
      title: "TikTok Video",
      subtitle: "TikTok",
      description: "í‹±í†¡ ë§í¬ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
      imageUrl: "",
      url: url,
      themeColor: "#000000",
      isEditable: true
    };
  }
};

// ğŸ¥ ë¹„ë©”ì˜¤ OEmbed (ê³ í™”ì§ˆ ì˜ìƒ)
const fetchVimeo = async (url: string): Promise<ScrapMetadata | null> => {
  try {
    const oembedUrl = `https://vimeo.com/api/oembed.json?url=${encodeURIComponent(url)}`;
    
    const PROXIES = [
      (url: string) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url: string) => `https://corsproxy.io/?${encodeURIComponent(url)}`
    ];

    for (let i = 0; i < PROXIES.length; i++) {
      try {
        const proxyUrl = PROXIES[i](oembedUrl);
        console.log(`ğŸ”„ ë¹„ë©”ì˜¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° ì‹œë„ (í”„ë¡ì‹œ ${i + 1}/${PROXIES.length})...`);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 7000);

        const response = await fetch(proxyUrl, { signal: controller.signal });
        clearTimeout(timeoutId);

        if (!response.ok) {
          console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì‹¤íŒ¨: ${response.status}`);
          continue;
        }

        const data = await response.json();
        console.log('âœ… ë¹„ë©”ì˜¤ OEmbed ë°ì´í„° ì„±ê³µ:', data);

        return {
          title: data.title || "Vimeo Video",
          subtitle: data.author_name || "Vimeo",
          description: data.description?.slice(0, 100) || "ê°ì„± ì˜ìƒ",
          imageUrl: data.thumbnail_url,
          url: url,
          themeColor: "#1AB7EA",
          isEditable: false
        };
      } catch (proxyError) {
        console.warn(`âš ï¸ í”„ë¡ì‹œ ${i + 1} ì—ëŸ¬:`, proxyError);
        if (i === PROXIES.length - 1) throw proxyError;
      }
    }

    throw new Error("All proxies failed");

  } catch (e) {
    console.error("âŒ Vimeo OEmbed Fetch ì™„ì „ ì‹¤íŒ¨:", e);
    return {
      title: "Vimeo Video",
      subtitle: "Vimeo",
      description: "ë¹„ë©”ì˜¤ ë§í¬ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
      imageUrl: "",
      url: url,
      themeColor: "#1AB7EA",
      isEditable: true
    };
  }
};

// ğŸ“º YouTube: Zero-Quota Strategy (Regex + OEmbed)
const fetchYoutube = async (url: string): Promise<ScrapMetadata | null> => {
    const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
    const match = url.match(regExp);
    const videoId = (match && match[2].length === 11) ? match[2] : null;

    if (!videoId) {
        console.warn("âš ï¸ YouTube ë¹„ë””ì˜¤ IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        return null;
    }

    // Try OEmbed for Title (No API Key needed, High Quota)
    let title = "YouTube Video";
    let author = "YouTube";
    try {
        console.log("ğŸ”„ YouTube OEmbed ë°ì´í„° ê°€ì ¸ì˜¤ê¸°...");
        const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
        
        // íƒ€ì„ì•„ì›ƒ ì„¤ì • (5ì´ˆ)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        const response = await fetch(oembedUrl, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (response.ok) {
            const data = await response.json();
            title = data.title || title;
            author = data.author_name || author;
            console.log("âœ… YouTube OEmbed ë°ì´í„° ì„±ê³µ:", { title, author });
        } else {
            console.warn("âš ï¸ YouTube OEmbed ì‹¤íŒ¨, ê¸°ë³¸ ì •ë³´ ì‚¬ìš©");
        }
    } catch (e) {
        console.warn("âš ï¸ YouTube OEmbed ì—ëŸ¬, ê¸°ë³¸ ì •ë³´ ì‚¬ìš©:", e);
        // Ignore oEmbed failure, fallback to basic ID
    }

    return {
      title: title,
      subtitle: author,
      description: "Watch on YouTube",
      imageUrl: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
      url: url,
      themeColor: "#FF0000",
      isEditable: false,
      // Default config, can be overridden by user modal
      youtubeConfig: { mode: 'player', startTime: 0 }
    };
};

// ğŸ¤– General/Commerce: Gemini AI with Grounding
const fetchWithGemini = async (url: string, type: ScrapType): Promise<ScrapMetadata> => {
    try {
        // API í‚¤ í™•ì¸
        if (!process.env.API_KEY) {
            console.warn("âš ï¸ API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. Fallback ë°ì´í„° ì‚¬ìš©");
            throw new Error("API_KEY not configured");
        }

        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        
        // Explicit prompt for JSON structure
        const prompt = `
          I am a web scraper. Analyze this URL: "${url}" (Type: ${type}).
          
          Extract or infer the following details in strict JSON format:
          {
            "title": "Main title, book name, or product name",
            "subtitle": "Author, Brand, Website Name, or Price",
            "description": "Short summary (max 120 chars)",
            "themeColor": "Hex color code matching the content (e.g. #FF0000)",
            "imageKeyword": "A single visual keyword to search for a background image if scraping fails"
          }
          
          Use Google Search Grounding to find real information.
        `;

        // íƒ€ì„ì•„ì›ƒ ì„¤ì • (10ì´ˆ)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
            controller.abort();
            console.warn("âš ï¸ Gemini API íƒ€ì„ì•„ì›ƒ");
        }, 10000);

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
                tools: [{ googleSearch: {} }],
                responseMimeType: "application/json"
            }
        });

        clearTimeout(timeoutId);

        const jsonText = response.text || "{}";
        let json;
        try {
            json = JSON.parse(jsonText);
        } catch {
            console.warn("âš ï¸ JSON Parse Failed, using fallback");
            json = { title: "Web Scrap", subtitle: "Website" };
        }
        
        // Deterministic Image Seed
        const seed = encodeURIComponent(json.imageKeyword || json.title || 'scrap');
        let imageUrl = `https://picsum.photos/seed/${seed}/400/400`;
        
        // Context-aware sizing
        if (type === ScrapType.BOOK) imageUrl = `https://picsum.photos/seed/${seed}/300/450`;
        if (type === ScrapType.FASHION) imageUrl = `https://picsum.photos/seed/${seed}/400/500`;

        // ë„ë©”ì¸ë³„ ë¸Œëœë“œ ìƒ‰ìƒ ë§¤í•‘
        let themeColor = json.themeColor || "#000000";
        
        // ê¸°ì¡´ íŒ¨ì…˜ ì‚¬ì´íŠ¸
        if (url.includes("musinsa.com")) themeColor = "#000000";
        else if (url.includes("29cm.co.kr")) themeColor = "#000000";
        
        // ğŸ‘‡ [ì¶”ê°€] íŒ¨ì…˜ & ë§¤ê±°ì§„ ì‚¬ì´íŠ¸
        else if (url.includes("wconcept.co.kr")) themeColor = "#000000"; // Wì»¨ì…‰ (ë¸”ë™)
        else if (url.includes("kream.co.kr")) themeColor = "#EF6253";   // í¬ë¦¼ (ì˜¤ë Œì§€)
        else if (url.includes("vogue.co.kr")) themeColor = "#E91E63";   // ë³´ê·¸ (ë ˆë“œ/í•‘í¬)
        else if (url.includes("elle.co.kr")) themeColor = "#000000";    // ì—˜ë¥´ (ë¸”ë™)
        
        // ê¸°íƒ€ ë¸Œëœë“œ
        else if (url.includes("nike.com")) themeColor = "#111111";
        else if (url.includes("adidas.com")) themeColor = "#000000";
        else if (url.includes("uniqlo.com")) themeColor = "#FF0000";

        return {
            title: json.title || "Web Scrap",
            subtitle: json.subtitle || new URL(url).hostname,
            description: json.description || "",
            imageUrl: imageUrl, 
            url: url,
            themeColor: themeColor,
            isEditable: false
        };

    } catch (e) {
        console.error("âŒ Gemini Fetch Failed:", e);
        
        // Fallback: URLì—ì„œ ë„ë©”ì¸ ì´ë¦„ ì¶”ì¶œ
        let hostname = "Website";
        try {
            hostname = new URL(url).hostname.replace('www.', '');
        } catch {}

        // ê¸°ë³¸ ë°ì´í„° ë°˜í™˜
        return {
            title: hostname,
            subtitle: "ì›¹ ë§í¬",
            description: "ìë™ ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ í™•ì¸í•˜ì„¸ìš”.",
            imageUrl: `https://picsum.photos/seed/${Date.now()}/400/400`,
            url: url,
            themeColor: "#64748b",
            isEditable: true // ì‚¬ìš©ìê°€ ì§ì ‘ í¸ì§‘ ê°€ëŠ¥
        };
    }
};

// --- 3. Main Facade (The "Proxy") ---

export const fetchMetadata = async (url: string, type: ScrapType): Promise<ScrapMetadata> => {
    // âš ï¸ DEPRECATED - ì •ì±… ìœ„ë°˜
    console.error('âŒ geminiService.fetchMetadataëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤!');
    console.error('âŒ ì´ìœ : í´ë¼ì´ì–¸íŠ¸ CORS í”„ë¡ì‹œ ì‚¬ìš©ìœ¼ë¡œ í”Œë«í¼ ToS ìœ„ë°˜');
    console.error('âœ… ëŒ€ì‹  services/apiClient.tsì˜ fetchMetadataë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
    
    throw new Error(
      'ì •ì±… ìœ„ë°˜: geminiServiceëŠ” deprecatedë˜ì—ˆìŠµë‹ˆë‹¤. ' +
      'services/apiClient.tsë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ /api/scrap APIë¥¼ í˜¸ì¶œí•˜ì„¸ìš”.'
    );
    
    // A. Check Cache First (Zero-Latency Return)
    const cached = getCachedData(url);
    if (cached) {
        console.log(`âš¡ Cache Hit: ${url}`);
        return cached;
    }

    console.log(`ğŸ”„ Fetching Fresh: ${url}`);
    let result: ScrapMetadata | null = null;

    try {
        // B. Route Logic based on Type
        switch (type) {
            case ScrapType.MOVING_PHOTO:
                const isVideo = url.toLowerCase().endsWith('.mp4');
                result = {
                    title: "Moving Photo",
                    subtitle: isVideo ? "Video Loop" : "Animated GIF",
                    description: "",
                    imageUrl: isVideo ? "" : url, // For video, we rely on videoUrl. For GIF, imageUrl.
                    videoUrl: isVideo ? url : undefined,
                    url: url,
                    isEditable: true,
                    themeColor: "#000000"
                };
                break;
            case ScrapType.PINTEREST:
                result = await fetchPinterest(url);
                break;
            case ScrapType.YOUTUBE:
                result = await fetchYoutube(url);
                break;
            case ScrapType.SPOTIFY:
                result = await fetchSpotify(url);
                break;
            case ScrapType.TIKTOK:
                result = await fetchTikTok(url);
                break;
            case ScrapType.VIMEO:
                result = await fetchVimeo(url);
                break;
            case ScrapType.TWITTER:
                // ğŸ¦ íŠ¸ìœ„í„° OEmbed HTML ê°€ì ¸ì˜¤ê¸°
                result = await fetchTwitterOEmbed(url);
                break;
            case ScrapType.INSTAGRAM:
                // Client-side Embeds don't need heavy fetching
                // We return minimal metadata and let the Embed component do the work
                result = {
                    title: "Instagram Post",
                    subtitle: "Instagram",
                    description: "",
                    imageUrl: "",
                    url: url,
                    themeColor: "#E1306C",
                    isEditable: false
                };
                break;
            default:
                // For General, Book, Fashion: Use AI
                result = await fetchWithGemini(url, type);
                break;
        }
    } catch (error) {
        console.error("Scraping failed:", error);
        result = null;
    }

    // C. Default Fallback & Cache Write
    const finalData = result || {
        title: "New Scrap Object",
        subtitle: "Click to Edit",
        description: "Could not load details automatically.",
        url: url,
        imageUrl: `https://picsum.photos/seed/${Date.now()}/400/400`,
        themeColor: "#64748b",
        isEditable: true
    };

    setCachedData(url, finalData);
    return finalData;
};